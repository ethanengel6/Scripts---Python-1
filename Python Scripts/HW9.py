# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iXflF1DjGfEJkGkWaei57zeg6-8CmSdp

1. Create a function, called ﬁndString, that takes a string and a ﬁle name as arguments and prints all lines in the ﬁle which contain the speciﬁed string (regardless of capitalization). Create a try and except clause to catch the error where the ﬁle name passed into the function is not found (this might happen either because the name of the ﬁle is misspelled or does not exist in the directory given) and prompt the user to enter the correct ﬁle name until successful. (Test using any text ﬁle) (20 points)
"""

def findString(strtoFind,fileName):
"""
Args: strtoFind(string)& fileName(text file)
No returns; finds the string in the lines of the file and prints those lines"""

    try:
      f=open(fileName, "r")
      lines=f.readlines()
      for z in range (len(lines)):
        if strtoFind.lower() in lines[z]:
          print(lines[z])

    except:
      fileName=input("Please enter the correct filename: ")
      findString("molasses",fileName)
    
    f.close()


findString("molasses", 'findMosses.txt')

"""2. Write a function, called wrapLines, that takes a ﬁle name and a length integer k.  The function wraps the lines longer than width k by splitting them into lines of length less than or equal to k, just like resizing a text editor window. Make sure not to break in the middle of a word. If the word is longer than k, you may split it using a hyphen or leaving the entire word on a single line. Create a try and except clause to catch the error where the ﬁle name passed into the function is not found (this might happen either because the name of the ﬁle is misspelled or does not exist in the directory given) and prompt the user to enter the correct ﬁle name until successful. (20 points)  Hint: You will need to read the ﬁle line by line then write the result back to the same ﬁle. (You can test this using any text ﬁle)"""

def wrapLines(resizeFile,k):
"""
Args: resizeFile(textfile) & k(int)
No returns; resizes length of lines to k # of characters"""
 
  try:
      f=open(resizeFile, "r+")
      lines=f.readlines()
     
  except:
      resizeFile=input("Please enter the correct filename: ")
      wrapLines(resizeFile,k)

 
  for qw in range (len(lines)):
    if len(lines[qw])<=k:
      f.write(lines[qw])
        
    else: 
      tooBig = [lines[qw][i:i+(k-1)] for i in range(0, len(lines[qw]), k-1)]
        
      for zz in range (len(tooBig)-1):
              tooBig[zz]+="-\n"
      for qq in range (len(tooBig)):
        f.write(tooBig[qq])
            
  f.close()
  
wrapLines("findMolasses.txt", 8)

"""3. Create a function, called allAnagrams, ﬁnd all anagrams in a dictionary. An anagram is a word formed of the rearrangements of the letters of another word. (20 points)  For example, listen and silent.  (A dictionary ﬁle is provided in the assignment folder. Testing your code on the entire dictionary may take a while so you can create a subset of words from the dictionary ﬁle to test your code)."""

def allAnagrams(anagramFile):
"""
Arg: anagramFile(textFile)
No returns; Finds all anagram pairs in a (abbreviated) dictionary and prints them as tuple pairs"""


    f=open(anagramFile,"r")
    dictList=f.readlines()
    
    anagramList=[]

    for q in range(len(dictList)-1):
      w=q+1
      while w<len(dictList):
        if (sorted(dictList[q])== sorted(dictList[w])): 
          anagramList.append((dictList[q],dictList[w]))
        w+=1
      
    print(anagramList)

    f.close()

allAnagrams("Anagrams.txt")

f=open("breastCancerData.csv","r")
dataList=[]
originalResult=set()
for lines in f:
  values=lines.split(",")
  del values[6:32]
  values[-1]=values[-1].strip('\n')
  dataList.append(values)
  if values[1].lower()=="m":
    originalResult.add(int(values[0]))
del dataList[0]


strippedData=open("strippedCancerData.txt","w+")
for strip in dataList:
  for qq in range(5):
    strippedData.write(strip[qq]+" ")
  strippedData.write(strip[5]+"\n")

radiusSet=set()
radiusBSet=set()
radiusMSet=set()
textureSet=set()
textureBSet=set()
textureMSet=set()
perimSet=set()
perimBSet=set()
perimMSet=set()
areaSet=set()
areaBSet=set()
areaMSet=set()

radius=open("q3_gte_13.txt","w+")
radiusB=open("q3_B.txt","w+")
radiusM=open("q3_M.txt","w+")
texture=open("q4_gte_18.txt","w+")
textureB=open("q4_B.txt","w+")
textureM=open("q4_M.txt","w+")
perim=open("q5_gte_85.txt","w+")
perimB=open("q5_B.txt","w+")
perimM=open("q5_M.txt","w+")
area=open("q6_gte_500.txt","w+")
areaB=open("q6_B.txt","w+")
areaM=open("q6_M.txt","w+")

for stats in dataList:

  if float(stats[2])>=13:
    radius.write((stats[0])+"\n")
    radiusSet.add(int(stats[0]))
  if float(stats[2])>=13 and stats[1].lower()=="b":
    radiusB.write(stats[0]+"\n")
    radiusBSet.add(int(stats[0]))
  if float(stats[2])>=13 and stats[1].lower()=="m":
    radiusM.write(stats[0]+"\n")
    radiusMSet.add(int(stats[0]))
  if float(stats[3])>=18:
    texture.write(stats[0]+"\n")
    textureSet.add(int(stats[0]))
  if float(stats[3])>=18 and stats[1].lower()=="b":
    textureB.write(stats[0]+"\n")
    textureBSet.add(int(stats[0]))
  if float(stats[3])>=18 and stats[1].lower()=="m":
    textureM.write(stats[0]+"\n")
    textureMSet.add(int(stats[0]))
  if float(stats[4])>=85:
    perim.write(stats[0]+"\n")
    perimSet.add(int(stats[0]))
  if float(stats[4])>=85 and stats[1].lower()=="b":  
    perimB.write(stats[0]+"\n")
    perimBSet.add(int(stats[0]))
  if float(stats[4])>=85 and stats[1].lower()=="m":  
    perimM.write(stats[0]+"\n")
    perimMSet.add(int(stats[0]))
  if float(stats[5])>=500:
    area.write(stats[0]+"\n")
    areaSet.add(int(stats[0]))
  if float(stats[5])>=500 and stats[1].lower()=="b": 
    areaB.write(stats[0]+"\n")
    areaBSet.add(int(stats[0]))
  if float(stats[5])>=500 and stats[1].lower()=="m": 
    areaM.write(stats[0]+"\n")
    areaMSet.add(int(stats[0]))



newResultSet=(radiusSet&textureSet)&(perimSet&areaSet)

subsetMResult=(radiusMSet|textureMSet)|(perimMSet|areaMSet)

      
difference_1=subsetMResult-newResultSet
difference_1List=sorted(list(difference_1))

difference_2=originalResult-newResultSet
difference_2List=sorted(list(difference_2))




print(difference_1List)
print(len(difference_1List))

print(difference_2List)
print(len(difference_2List))


#Question 1:  The n value of the set where all 4 indicators(radius,texture,perimeter & area) are higher than the set thresholds is 210.  The n value of the set where at least one indicator is high and the tumor was diagnosed malignant is also 210.
#The difference of these sets has an n value of 39.  This would mean that there are 39 tumors of 210 that measure high on all 4 indicators but were not diagnosed as malignant.

#Question2: There were 212 tumors of this set diagnosed as malignant.  As mentioned in question 3, there were 210 tumors where all 4 of the indicators were above the measurement thresholds.
#The difference of these sets had an n value of 41.  So there were 41 tumors diagnosed as malignant that were not above all 4 measurement thresholds.

#Question3:  Although the 2 set differences have similar n values, they are not precisely equal.  That is because the approaches are different.  The first case doesn't capture all of the same data, because just because a tumor measures high on all of the indicators, does not necessarily mean that it is malignant.
#For difference2.  Not all of the data is captured because a malignant diagnosis does not guarantee that all four of the attributes are high.  The differences are not the same data in each case.

