# -*- coding: utf-8 -*-
"""HW6.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XOjMTo7t3ZNU2BS_DO8HFQ7fVQaECOeF

1. Write a function, called listToDict, that takes a list as an argument and returns a dictionary
containing the keys 1 through n, where n is the size of the list, and the values correspond to
the values in the list.
For example, if the list is [2, 6, 6, 1, 7, 9] then the dictionary maps 1 —> 2, 2 —> 6, 3 —>6,
4 —> 1, 5 —> 7 and 6 —> 9. (20 points)
"""

def listtoDict(list):
  """
  Arg: 
    list(list) of any elements
  Returns:
    newDict(Dictionary):the list as values with numerical keys """
  newDict={}
  for z in range (1,len(list)+1):
    newDict.update({z:list[z-1]})
  return(newDict)

"""2. Write a function, called newDict, that takes a dictionary as an argument and returns a new
dictionary with the keys and values inverted (keys become values and values become
keys).
What happens if there are duplicate values? Short comment with the answer if fine (20 points)
"""

def newDict(dictToFlip):
  """
  Arg:
    dictToFlip(Dictionary): arbitrary key value pairs
  Returns: 
    newDictionary(Dictionary): new dictionary with keys&values inverted"""
  #If the original dictionary has a duplicate value(s), then the last to be iterated over will replace the other keys, since dictionaries cannot have duplicate keys.
  newDictionary={}
  keystoVals=[]
  valstoKeys=[]
  for z in dictToFlip.keys():
    keystoVals.append(z)
  for y in dictToFlip.values():
    valstoKeys.append(y)
  for j in range(len(keystoVals)):
    newDictionary.update({valstoKeys[j]:keystoVals[j]})
  return(newDictionary)

"""3. Write a function, called uniqueElems, that takes a list of values as a parameter and
determines if all elements are unique (no repeated values). Return True if all values are
unique, False otherwise. Think of a way to use dictionary to perform this task. (20 points)
"""

def uniqueElems(listofValues):
  """
  Arg:
    listofValues(List):arbitrary values
  Returns:
    True if there are no duplicates
    False if there are >= 1 duplicate pair"""
  dictofValues={}
  k=0
  for h in range(len(listofValues)-1,-1,-1):
    dictofValues.update({h:listofValues[h]}
  
  for j in range(len(listofValues)-1,0,-1):
      k=0
      for k in range(j-1):
        if dictofValues[j]==dictofValues[k]:
          return False
        k+=1
  return True

"""4. Write a function, called valFrequency, that given a list of values as a parameter, counts the
frequencies for each value in the list. You can do this by returning a dictionary (think about
what the key should be and what value should be associated with it).
For example, if the list is [1, 3, 5, 2, 1, 2, 5, 8, 4, 5] then we have 2 x1's, 1 x 3's, 3 x 5's, 2 x
2's, 1x4's, 1x8’s (20 points)
"""

def valFrequency(listtoCount):
  """
  Arg: listtoCount(list):arbitrary list of elements
  returns:
    dictofCounts(dictionary):key=element from list; value = count of that element"""
  dictofCounts={}
  for cc in range(len(listtoCount)):
    dictofCounts.update({listtoCount[cc]:listtoCount.count(listtoCount[cc])})
  return(dictofCounts)

"""5. Write a function, called addsToK, that given an integer k and a list of n unordered integers
A, determines if there is a pair of distinct integers in A that add up to k. Returns True if they
are, False otherwise.
For example : given [1, 6, 7, 3, 7, 10, 3] if k=13 then there is a pair of integers that add up to
13 : 10 and 3. If k=14 then there isn’t a pair of distinct integers that add up to 14 (can’t use
7 twice even if it appears twice in the list) (20 points)
"""

def addsToK(K,listA):
  """
    Args:
      k(int):arbitrary
      listA(list):list of integers
    returns:
      true if any nonduplicate values in the list sum to k
      false otherwise"""
  for zz in range(0,len(listA)-1):
      yy=zz+1
      while yy<=len(listA)-1:
          if ((listA[zz]+listA[yy])==K) and (listA[zz]!=listA[yy]):
            return True
          yy+=1
  return False
addsToK(5,[1,3,2,5,6,7])

